if(!require(p,character.only = TRUE)) install.packages(p)
library(p,character.only = TRUE)
}
# ----------
# Step 1: Load csv file
# ----------
setwd(this.path::here())
#Current Directory
getwd()
read_dirty_csv <-read_csv("dirty_data.csv")
read_missing_data_csv <-read_csv("missing_data.csv")
read_warehouses_csv <-read_csv("warehouses.csv")
## Convert 2 csv date_cols before merge
read_dirty_csv$date <- parse_date_time(read_dirty_csv$date, orders = c("mdy", "ymd", "dmy"))
read_missing_data_csv$date <- parse_date_time(read_missing_data_csv$date, orders = c("mdy", "ymd", "dmy"))
read_dirty_data <- rbind(read_dirty_csv, read_missing_data_csv)
# ----------
# Step 2: Clean Data
# ----------
## [Season]
## Convert all value to lowercase
read_dirty_data$season<- tolower( read_dirty_data$season )
month_value <- month(read_dirty_data$date)
## Use Month to Detect Seaason
read_dirty_data <- read_dirty_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "winter",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
## [is_happy_customer] : Using mean value
value_is_happy_customer<-median(read_dirty_data$is_happy_customer,na.rm = TRUE)
# dùng mean để tính customer_mean và long
value_customer_long<-mean(read_dirty_data$customer_long,na.rm = TRUE)
value_cusomter_lat<-mean(read_dirty_data$customer_lat,na.rm = TRUE)
## làm tròn
rounded_happy_customer = round(value_is_happy_customer,digits = 0)
rounded_customer_long = round(value_customer_long,digits = 0)
rounded_customer_lat = round(value_customer_lat,digits=0)
# ----------
# Step 0: Install packages
# ----------
# List of packages to install
# List of required packages
required_packages = c("this.path","dplyr", "ggplot2", "lubridate", "geosphere", "readr", "corrplot", "faraway", "car")
for(p in required_packages){
if(!require(p,character.only = TRUE)) install.packages(p)
library(p,character.only = TRUE)
}
# ----------
# Step 1: Load csv file
# ----------
setwd(this.path::here())
#Current Directory
getwd()
read_dirty_csv <-read_csv("dirty_data.csv")
read_missing_data_csv <-read_csv("missing_data.csv")
read_warehouses_csv <-read_csv("warehouses.csv")
## Convert 2 csv date_cols before merge
read_dirty_csv$date <- parse_date_time(read_dirty_csv$date, orders = c("mdy", "ymd", "dmy"))
read_missing_data_csv$date <- parse_date_time(read_missing_data_csv$date, orders = c("mdy", "ymd", "dmy"))
read_dirty_data <- rbind(read_dirty_csv, read_missing_data_csv)
# ----------
# Step 2: Clean Data
# ----------
## [Season]
## Convert all value to lowercase
read_dirty_data$season<- tolower( read_dirty_data$season )
month_value <- month(read_dirty_data$date)
## Use Month to Detect Seaason
read_dirty_data <- read_dirty_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "winter",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
## [is_happy_customer] : Using mean value
value_is_happy_customer<-median(read_dirty_data$is_happy_customer,na.rm = TRUE)
# dùng mean để tính customer_mean và long
value_customer_long<-mean(read_dirty_data$customer_long,na.rm = TRUE)
value_customer_lat<-mean(read_dirty_data$customer_lat,na.rm = TRUE)
## làm tròn
rounded_happy_customer = round(value_is_happy_customer,digits = 0)
rounded_customer_long = round(value_customer_long,digits = 0)
rounded_customer_lat = round(value_customer_lat,digits=0)
## Gán giá trị vào cột is_happy_customer cột nào bị thiếu (NA)
read_dirty_data$is_happy_customer[is.na(read_dirty_data$is_happy_customer)]<- rounded_happy_customer
read_dirty_data$customer_lat[is.na(read_dirty_data$customer_lat)]<- rounded_customer_lat
read_dirty_data$customer_long[is.na(read_dirty_data$customer_long)]<- rounded_customer_long
na_cout <- colSums(is.na(read_dirty_data ))
print(na_cout)
df1 %>%
filter(if_all(everything(), is.na))
read_dirty_data %>%
filter(if_all(everything(), is.na))
# Price of Product
read_dirty_data[!complete.cases(df),]
read_dirty_data[!complete.cases(read_dirty_data),]
read_dirty_data[is.na(read_dirty_data$order_price) | is.na(df$total_price),] # if you want to specify specific columns
read_dirty_data[!complete.cases(read_dirty_data),]
#read_dirty_data[!complete.cases(read_dirty_data),]
read_dirty_data[is.na(read_dirty_data$order_price) | is.na(read_dirty_data$total_price),]
#read_dirty_data[!complete.cases(read_dirty_data),]
read_dirty_data[is.na(read_dirty_data$order_price) | is.na(read_dirty_data$total_order),]
#read_dirty_data[!complete.cases(read_dirty_data),]
read_dirty_data[is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
#read_dirty_data[!complete.cases(read_dirty_data),]
price_na<-read_dirty_data[is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
write.csv(price_na,"price_na.csv")
price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
write.csv(price_na,"price_na.csv")
price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
write.csv(price_na,"price_na.csv")
## With price of item, we can use
na_count <- colSums(is.na(read_dirty_csv))
print(na_count)
na_count <- colSums(is.na(read_dirty_data))
print(na_count)
read_dirty_data$order_total[is.na(read_dirty_data$order_price + 1)]
na_count <- colSums(is.na(read_dirty_data))
print(na_count)
read_dirty_data <- read_dirty_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
na_cout <- colSums(is.na(read_dirty_data ))
na_cout <- colSums(is.na(read_dirty_data ))
print(na_count)
read_dirty_data <- read_dirty_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
na_cout <- colSums(is.na(read_dirty_data ))
print(na_count)
# ----------
# Step 0: Install packages
# ----------
# List of packages to install
# List of required packages
required_packages = c("this.path","dplyr", "ggplot2", "lubridate", "geosphere", "readr", "corrplot", "faraway", "car")
for(p in required_packages){
if(!require(p,character.only = TRUE)) install.packages(p)
library(p,character.only = TRUE)
}
# ----------
# Step 1: Load csv file
# ----------
setwd(this.path::here())
#Current Directory
getwd()
read_dirty_csv <-read_csv("dirty_data.csv")
read_missing_data_csv <-read_csv("missing_data.csv")
read_warehouses_csv <-read_csv("warehouses.csv")
## Convert 2 csv date_cols before merge
read_dirty_csv$date <- parse_date_time(read_dirty_csv$date, orders = c("mdy", "ymd", "dmy"))
read_missing_data_csv$date <- parse_date_time(read_missing_data_csv$date, orders = c("mdy", "ymd", "dmy"))
read_dirty_data <- rbind(read_dirty_csv, read_missing_data_csv)
# ----------
# Step 2: Clean Data
# ----------
## [Season]
## Convert all value to lowercase
read_dirty_data$season<- tolower( read_dirty_data$season )
month_value <- month(read_dirty_data$date)
## Extract Month in date coulmn
read_dirty_data <- read_dirty_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "winter",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
## [is_happy_customer] : Using median
## [customer_lat]: Using mean
## [customer_long] : Using mean
value_is_happy_customer<-median(read_dirty_data$is_happy_customer,na.rm = TRUE)
value_customer_long<-mean(read_dirty_data$customer_long,na.rm = TRUE)
value_customer_lat<-mean(read_dirty_data$customer_lat,na.rm = TRUE)
## Rounded the result
rounded_happy_customer = round(value_is_happy_customer,digits = 0)
rounded_customer_long = round(value_customer_long,digits = 0)
rounded_customer_lat = round(value_customer_lat,digits=0)
## Assign value into empty row (NA)
read_dirty_data$is_happy_customer[is.na(read_dirty_data$is_happy_customer)]<- rounded_happy_customer
read_dirty_data$customer_lat[is.na(read_dirty_data$customer_lat)]<- rounded_customer_lat
read_dirty_data$customer_long[is.na(read_dirty_data$customer_long)]<- rounded_customer_long
# Price of Product
#read_dirty_data[!complete.cases(read_dirty_data),]
#price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
#write.csv(price_na,"price_na.csv")
## With price of item, we can use
## Change NA value
read_dirty_data <- read_dirty_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
na_cout <- colSums(is.na(read_dirty_data ))
print(na_count)
# ----------
# Step 0: Install packages
# ----------
# List of packages to install
# List of required packages
required_packages = c("this.path","dplyr", "ggplot2", "lubridate", "geosphere", "readr", "corrplot", "faraway", "car")
for(p in required_packages){
if(!require(p,character.only = TRUE)) install.packages(p)
library(p,character.only = TRUE)
}
# ----------
# Step 1: Load csv file
# ----------
setwd(this.path::here())
#Current Directory
getwd()
read_dirty_csv <-read_csv("dirty_data.csv")
read_missing_data_csv <-read_csv("missing_data.csv")
read_warehouses_csv <-read_csv("warehouses.csv")
## Convert 2 csv date_cols before merge
read_dirty_csv$date <- parse_date_time(read_dirty_csv$date, orders = c("mdy", "ymd", "dmy"))
read_missing_data_csv$date <- parse_date_time(read_missing_data_csv$date, orders = c("mdy", "ymd", "dmy"))
read_dirty_data <- rbind(read_dirty_csv, read_missing_data_csv)
# ----------
# Step 2: Clean Data
# ----------
## [Season]
## Convert all value to lowercase
read_dirty_data$season<- tolower( read_dirty_data$season )
month_value <- month(read_dirty_data$date)
## Extract Month in date coulmn
read_dirty_data <- read_dirty_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "winter",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
## [is_happy_customer] : Using median
## [customer_lat]: Using mean
## [customer_long] : Using mean
value_is_happy_customer<-median(read_dirty_data$is_happy_customer,na.rm = TRUE)
value_customer_long<-mean(read_dirty_data$customer_long,na.rm = TRUE)
value_customer_lat<-mean(read_dirty_data$customer_lat,na.rm = TRUE)
## Rounded the result
rounded_happy_customer = round(value_is_happy_customer,digits = 0)
rounded_customer_long = round(value_customer_long,digits = 0)
rounded_customer_lat = round(value_customer_lat,digits=0)
## Assign value into empty row (NA)
read_dirty_data$is_happy_customer[is.na(read_dirty_data$is_happy_customer)]<- rounded_happy_customer
read_dirty_data$customer_lat[is.na(read_dirty_data$customer_lat)]<- rounded_customer_lat
read_dirty_data$customer_long[is.na(read_dirty_data$customer_long)]<- rounded_customer_long
# Price of Product
#read_dirty_data[!complete.cases(read_dirty_data),]
#price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
#write.csv(price_na,"price_na.csv")
## With price of item, we can use
## Change NA value
read_dirty_data <- read_dirty_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
write.csv(price_na,"price_na_new.csv")
na_cout<- colSums(is.na(new_dirty_data ))
na_cout<- colSums(is.na(read_dirty_data ))
print(na_cout)
## Distance to nearest warehouse
print(read_warehouses_csv)
customer_coords <- cbind(new_dirty_data$customer_long, new_dirty_data$customer_lat)
customer_coords <- cbind(read_data_dirty$customer_long, read_data_dirty$customer_lat)
customer_coords <- cbind(read_dirty_data$customer_long, read_dirty_data$customer_lat)
print(customer_coords)
customer_coords <- cbind(read_dirty_data$customer_long, read_dirty_data$customer_lat)
print(customer_coords)
#customer_coords <- cbind(new_dirty_data$customer_long, new_dirty_data$customer_lat)
warehouse_coords <- cbind(read_warehouses_csv$lon, read_warehouses_csv$lat)
print(warehouse_coords)
all_distances <- distm(customer_coords, warehouse_coords, fun = distVincentySphere)
print(all_distances)
min_distances <- apply(all_distances, 1, min)
min_distances <- apply(all_distances, 1, min)
print(min_distances)
read_dirty_data$distance_to_nearest_warehouse <- round(min_distances / 1000, digits = 4)
na_cout<- colSums(is.na(new_dirty_data ))
na_cout<- colSums(is.na(read_dirty_data ))
print(na_cout)
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
print(nearest_warehouse_idx)
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
print(nearest_warehouse_idx)
nearest_warehouses <- warehouse_data$names[nearest_warehouse_idx]
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
print(nearest_warehouse_idx)
nearest_warehouses <- read_warehouses_csv$names[nearest_warehouse_idx]
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
print(nearest_warehouse_idx)
nearest_warehouses <- read_warehouses_csv$names[nearest_warehouse_idx]
print(nearest_warehouses)
# ----------
# Step 0: Install packages
# ----------
# List of packages to install
# List of required packages
required_packages = c("this.path","dplyr", "ggplot2", "lubridate", "geosphere", "readr", "corrplot", "faraway", "car")
for(p in required_packages){
if(!require(p,character.only = TRUE)) install.packages(p)
library(p,character.only = TRUE)
}
# ----------
# Step 1: Load csv file
# ----------
setwd(this.path::here())
#Current Directory
getwd()
read_dirty_csv <-read_csv("dirty_data.csv")
read_missing_data_csv <-read_csv("missing_data.csv")
read_warehouses_csv <-read_csv("warehouses.csv")
## Convert 2 csv date_cols before merge
read_dirty_csv$date <- parse_date_time(read_dirty_csv$date, orders = c("mdy", "ymd", "dmy"))
read_missing_data_csv$date <- parse_date_time(read_missing_data_csv$date, orders = c("mdy", "ymd", "dmy"))
read_dirty_data <- rbind(read_dirty_csv, read_missing_data_csv)
# ----------
# Step 2: Clean Data
# ----------
## [Season]
## Convert all value to lowercase
read_dirty_data$season<- tolower( read_dirty_data$season )
month_value <- month(read_dirty_data$date)
## Extract Month in date coulmn
read_dirty_data <- read_dirty_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "winter",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
## [is_happy_customer] : Using median
## [customer_lat]: Using mean
## [customer_long] : Using mean
value_is_happy_customer<-median(read_dirty_data$is_happy_customer,na.rm = TRUE)
value_customer_long<-mean(read_dirty_data$customer_long,na.rm = TRUE)
value_customer_lat<-mean(read_dirty_data$customer_lat,na.rm = TRUE)
## Rounded the result
rounded_happy_customer = round(value_is_happy_customer,digits = 0)
rounded_customer_long = round(value_customer_long,digits = 0)
rounded_customer_lat = round(value_customer_lat,digits=0)
## Assign value into empty row (NA)
read_dirty_data$is_happy_customer[is.na(read_dirty_data$is_happy_customer)]<- rounded_happy_customer
read_dirty_data$customer_lat[is.na(read_dirty_data$customer_lat)]<- rounded_customer_lat
read_dirty_data$customer_long[is.na(read_dirty_data$customer_long)]<- rounded_customer_long
# Price of Product
#read_dirty_data[!complete.cases(read_dirty_data),]
#price_na<-read_dirty_data[is.na(read_dirty_data$coupon_discount)| is.na(read_dirty_data$order_price) | is.na(read_dirty_data$order_total),] # if you want to specify specific columns
#write.csv(price_na,"price_na.csv")
## With price of item, we can use
## Change NA value
read_dirty_data <- read_dirty_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
## Distance to nearest warehouse
print(read_warehouses_csv)
customer_coords <- cbind(read_dirty_data$customer_long, read_dirty_data$customer_lat)
print(customer_coords)
#customer_coords <- cbind(new_dirty_data$customer_long, new_dirty_data$customer_lat)
warehouse_coords <- cbind(read_warehouses_csv$lon, read_warehouses_csv$lat)
print(warehouse_coords)
#warehouse_cords  <- cbind(read_warehouses_csv)
all_distances <- distm(customer_coords, warehouse_coords, fun = distVincentySphere)
#print(all_distances)
min_distances <- apply(all_distances, 1, min)
#print(min_distances)
read_dirty_data$distance_to_nearest_warehouse <- round(min_distances / 1000, digits = 4)
## Lấy tên kho hàng gần nhất
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
print(nearest_warehouse_idx)
nearest_warehouses <- read_warehouses_csv$names[nearest_warehouse_idx]
read_dirty_data$nearest_warehouse <- round(min_distances / 1000, digits = 4)
na_cout<- colSums(is.na(read_dirty_data ))
print(na_cout)
# ----------
# Step 0: Install and Load Packages
# ----------
required_packages <- c("this.path", "dplyr", "ggplot2", "lubridate", "geosphere",
"readr", "corrplot", "faraway", "car")
for (p in required_packages) {
if (!require(p, character.only = TRUE)) install.packages(p)
library(p, character.only = TRUE)
}
# ----------
# Step 1: Load and Merge Data
# ----------
setwd(this.path::here())
# Current Directory
cat("Current Directory:", getwd(), "\n")
# Load CSV files
dirty_data <- read_csv("dirty_data.csv")
missing_data <- read_csv("missing_data.csv")
warehouses <- read_csv("warehouses.csv")
# Parse date columns in dirty_data and missing_data
dirty_data$date <- parse_date_time(dirty_data$date, orders = c("mdy", "ymd", "dmy"))
missing_data$date <- parse_date_time(missing_data$date, orders = c("mdy", "ymd", "dmy"))
# Merge dirty_data and missing_data
merged_data <- rbind(dirty_data, missing_data)
# ----------
# Step 2: Clean Data
# ----------
# Convert 'season' to lowercase and fill missing values
merged_data$season <- tolower(merged_data$season)
month_value <- month(merged_data$date)
merged_data <- merged_data %>%
mutate(season = case_when(
!is.na(season) ~ season,  # Keep existing values
month_value %in% c(12, 1, 2) ~ "winter",
month_value %in% c(3, 4, 5) ~ "spring",
month_value %in% c(6, 7, 8) ~ "summer",
TRUE ~ "autumn"
))
# Fill missing values in 'is_happy_customer' using median
median_happy_customer <- round(median(merged_data$is_happy_customer, na.rm = TRUE), digits = 0)
merged_data$is_happy_customer[is.na(merged_data$is_happy_customer)] <- median_happy_customer
# Fill missing values in 'customer_lat' and 'customer_long' using mean
mean_customer_lat <- round(mean(merged_data$customer_lat, na.rm = TRUE), digits = 0)
mean_customer_long <- round(mean(merged_data$customer_long, na.rm = TRUE), digits = 0)
merged_data$customer_lat[is.na(merged_data$customer_lat)] <- mean_customer_lat
merged_data$customer_long[is.na(merged_data$customer_long)] <- mean_customer_long
# Clean order data: Fill NA values in 'order_total' and 'order_price'
merged_data <- merged_data %>%
mutate(
order_total = ifelse(
is.na(order_total),
order_price * (100 - coupon_discount) / 100 + delivery_charges,
order_total
),
order_price = ifelse(
is.na(order_price),
(order_total - delivery_charges) * 100 / (100 - coupon_discount),
order_price
)
)
# ----------
# Step 3: Calculate Distances to Nearest Warehouse
# ----------
customer_coords <- cbind(merged_data$customer_long, merged_data$customer_lat)
warehouse_coords <- cbind(warehouses$lon, warehouses$lat)
# Compute distance matrix between customers and warehouses
all_distances <- distm(customer_coords, warehouse_coords, fun = distVincentySphere)
# Find minimum distances and corresponding warehouses
min_distances <- apply(all_distances, 1, min)
nearest_warehouse_idx <- apply(all_distances, 1, which.min)
# Add distance and nearest warehouse to merged_data
merged_data$distance_to_nearest_warehouse <- round(min_distances / 1000, digits = 4)
merged_data$nearest_warehouse <- warehouses$names[nearest_warehouse_idx]
# ----------
# Step 4: Check for Remaining Missing Values
# ----------
na_count <- colSums(is.na(merged_data))
cat("Remaining Missing Values in Each Column:\n")
print(na_count)
# Save the cleaned data if needed
# write_csv(merged_data, "cleaned_data.csv")
